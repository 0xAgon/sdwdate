#!/usr/bin/env python

import sys
import logging
import signal
import os
import time
from datetime import datetime
import random
from random import randint
from subprocess import Popen, call, PIPE, check_output
import pickle
import re

from sdwdate.remote_times import get_time_from_servers
from sdwdate.config import read_pools
from sdwdate.timesanitycheck import timesanitycheck

class Pool:
    def __init__(self, pool):
        self.url, self.comment = read_pools(pool)
        self.url_random = []
        self.already_picked_index = []
        self.done = False

    @property
    def url_range(self):
        return len(self.url)


class Sdwdate():
    def __init__(self):
        self.iteration = 0
        self.number_of_pools = 3

        self.pools = [Pool(pool) for pool in range(self.number_of_pools)]
        self.urls = []
        self.url_random = []
        self.valid_urls = []
        self.unixtimes = []
        self.pools_diff = []
        self.invalid_urls = []
        self.url_errors = []

        self.median = 0
        self.range_nanoseconds = 999999999
        self.new_diff = 0
        self.newdiff_nanoseconds = 0

        self.sclockadj_pid = 0

        self.last_shell_date = ''

        self.first_success_path = '/var/run/sdwdate/first_success'
        self.success_path = '/var/run/sdwdate/success'
        self.status_path = '/var/run/sdwdate/status'

        self.success_icon = '/usr/share/icons/sdwdate-gui/Ambox_currentevent.svg.png'
        self.busy_icon = '/usr/share/icons/sdwdate-gui/620px-Ambox_outdated.svg.png'
        self.error_icon = '/usr/share/icons/sdwdate-gui/212px-Timeblock.svg.png'

        self.first_success = os.path.exists(self.first_success_path)
        self.success = os.path.exists(self.success_path)

        self.status = {'icon' : '', 'message' : ''}

        self.message = ''

    def general_proxy_error(self, pools):
        '''
        This error occurs (at least) when Tor is not running.
        '''
        try:
            if (pools[0] == 'Connection closed unexpectedly' and
                pools[1] == 'Connection closed unexpectedly' and
                pools[2] == 'Connection closed unexpectedly'):
                    return True
        # If tor is stopping during a cycle, some urls are not returned,
        # raising an error.
        except IndexError:
            return True
        return False

    def check_remote(self, remote, value):
        '''
        Check returned value. True if numeric.
        '''
        try:
            n = int(value)
            message = 'Remote status "%s", True' % (remote)
            print(message)
            logger.info(message)
            return True
        except ValueError:
            message = 'Remote status "%s", False: %s' % (remote, value)
            print(message)
            logger.info(message)
            return False

    def get_comment(self, remote):
        ''' For logging the commnents, get the index of the url
            to get it from pool.comment.
        '''
        for url in self.pools:
            try:
                url_index = url.url.index(remote)
                url_comment = url.comment[url_index]
            except ValueError:
                pass
        return url_comment

    def time_sanity_check(self):
        status, time_one, time_two = timesanitycheck()

        if status == 'sane':
            self.message = 'The clock is %s. Current time "%s".' % (status, time_one)
        elif status == 'slow':
            self.message = ('The clock is %s.<br> Current time [%s] is less than the build timestamp [%s]'
                % (status, time_one, time_two))
        elif status == 'fast':
            self.message = ('The clock is %s.<br> Current time [%s] is greater than the expiration timestamp [%s]'
                % (status, time_one, time_two))
        return status

    def build_median(self):
        '''
        Get the median (not average) from the list of values.
        '''
        diffs = sorted(self.pools_diff)
        message = 'Pool differences, sorted: %s' % diffs
        print(message)
        logger.info(message)
        self.median = diffs[(len(diffs) / 2)]

    def set_new_time(self):
        '''
        Do not set time if diff = 0.
        '''
        if self.median == 0:
            message = 'Time difference = 0. Not setting time'
            print(message)
            logger.info(message)
            return False
        else:
            return True

    def add_subtract_nanoseconds(self):
        '''
        Could we replace this in sdwdate_loop pool_diff calculations?
        -> int(web_time) - old_unixtime
        '''
        signs = ['+', '-']
        sign = randint(0, 1)
        nanoseconds = randint(0, self.range_nanoseconds)
        seconds = float(nanoseconds) / 1000000000

        if sign == 0:
            self.new_diff = self.median + seconds
        else:
            self.new_diff = self.median - seconds

        self.newdiff_nanoseconds = int(self.new_diff * 1000000000)

        #print 'nanoseconds %s' % nanoseconds
        message = 'Median time difference: %s' % self.median
        print(message)
        logger.info(message)
        message = 'Seconds to add: %s %s' % (signs[sign], seconds)
        print(message)
        logger.info(message)
        message = 'New time difference: %s' % self.new_diff
        print(message)
        logger.info(message)

    def run_sclockadj(self):
        '''
        Set time with sneaky_clock_adjuster.
        Should we use sclockadj_debug_helper?
        '''
        if self.newdiff_nanoseconds > 0:
            add_subtract = "--add"
        else:
            add_subtract = "--subtract"
        cmd = [
            "sudo",
            "INLINEDIR=/var/cache/sdwdate/sclockadj",
            "/usr/lib/sdwdate/sclockadj",
            "--no-debug",
            "--no-verbose",
            "--no-systohc",
            "--no-first-wait",
            "--move-min", "5000000",
            "--move-max", "5000000",
            "--wait-min", "1000000000",
            "--wait-max", "1000000000",
            add_subtract, str(abs(self.newdiff_nanoseconds))]

        ## Run sclockadj in a subshell.
        sclockadj = Popen(cmd)
        self.sclockadj_pid = sclockadj.pid

        message = 'Gradually adjusting the time by running sclockadj, PID=%s' % (self.sclockadj_pid)
        print(message)
        logger.info(message)

        ## Running sclockadj_debug_helper, in case...
        ## May be read the last line to ensure sclockadj is running.
        #cmd = ["sudo", "/usr/lib/sdwdate/sclockadj_debug_helper"]
        ### Pipe stdout in subprocess.
        #helper = Popen(cmd, stdout=PIPE)
        ### Read the output.
        #line = helper.stdout.read()
        #print line

    def kill_sclockadj(self):
        '''
        '''
        cmd = 'sudo /usr/lib/sdwdate/sclockadj_kill_helper ' + str(self.sclockadj_pid)
        call(cmd, shell=True)

    def set_time_using_date(self):
        old_unixtime = float('%.9f' % (time.time()))
        message = 'Old unixttime: %s' % (str(old_unixtime))
        print(message)
        logger.info(message)

        new_unixtime = float('%.9f' % (old_unixtime + self.new_diff))
        message = 'New unixtime %s' % (str(new_unixtime))
        print(message)
        logger.info(message)

        ## Set new time.
        cmd = 'sudo /bin/date --set @' + str(new_unixtime)
        call(cmd, shell=True)

        message = 'Instantly setting the time by using command "%s"' % cmd
        print(message)
        logger.info(message)

    def write_status(self, *args):
        self.status['icon'] = args[0]
        self.status['message'] = args[1]
        with open(self.status_path, 'wb') as f:
            pickle.dump(self.status, f)

    def sdwdate_loop(self):
        '''
        Check remotes.
        Pick a random url in each pool, check the returned value.
        Append valid urls if time is returned, otherwise restart a cycle
        with a new random url, until every pool has a time value.
        '''
        start_unixtime = time.time()
        start_time = (datetime.strftime(datetime.fromtimestamp(start_unixtime),
                                        '%a %b %d %H:%M:%S UTC %Y'))
        message = ('Fetching remote times, start %s (unixtime %s)'
                   % (start_time, start_unixtime))
        print(message)
        logger.info(message)

        time_sanity_check = self.time_sanity_check()
        if time_sanity_check == 'sane':
            print self.message
            logger.info(self.message)
        else:
            stripped_message = re.sub('<[^<]+?>', '', self.message)
            print self.message
            return self.error_icon, 'error'

        global retrying_loop

        if self.success:
            if not retrying_loop:
                ## Update tool tip.
                ## Update icon after SIGTERM.
                self.write_status(self.success_icon, 'Fetching remote times...')
        else:
            if not self.first_success:
                self.write_status(self.busy_icon, 'No internet. Fetching remote times...')
            else:
                self.write_status(self.success_icon, 'Fetching remote times...')

        while len(self.valid_urls) < self.number_of_pools:
            self.iteration = self.iteration + 1
            message = 'Running sdwdate loop, iteration %s' % (self.iteration)
            print(message)
            logger.info(message)

            ## Clear the lists.
            self.urls[:] = []
            self.url_random[:] = []

            for pool in self.pools:
                if not pool.done:
                    url_index = random.randrange(0, pool.url_range)

                    if len(pool.already_picked_index) >= len(pool.url):
                        self.message = ' Time is not set: no valid time returned from pool one'
                        logger.warning(self.message)
                        return self.error_icon, 'error'

                    pool.already_picked_index.append(url_index)
                    pool.url_random.append(pool.url[url_index])
                    self.url_random.append(pool.url[url_index])

            ## Fetch remotes.
            if len(self.url_random) > 0:
                message = 'Requested urls %s' % (self.url_random)
                print(message)
                logger.info(message)

                self.urls, self.returned_values = get_time_from_servers(self.url_random)

                if len(self.urls) == 0:
                    if retrying_loop:
                        retrying_loop = False
                        self.message = 'No values returned from servers.<br> Internet connection might be down.'
                        return self.error_icon, 'error'
                    else:
                        retrying_loop = True
                        self.message = 'No values returned from url_to_unixtime.<br> Retrying...'
                        return self.busy_icon, 'retry'

                message = 'Returned urls "%s"' % (self.urls)
                print(message)
                logger.info(message)

            else:
                self.message = ('Something is wrong. sdwdate loop could not build a list or urls.<br>'
                                ' Please report this bug')
                print(message)
                return self.error_icon, 'error'

            if not self.general_proxy_error(self.returned_values):
                for i in range(len(self.urls)):
                    if self.check_remote(self.urls[i], self.returned_values[i]):
                        self.valid_urls.append(self.urls[i])
                        self.unixtimes.append(self.returned_values[i])
                    else:
                        self.invalid_urls.append(self.urls[i])
                        self.url_errors.append(self.returned_values[i])
            else:
                self.message = 'General Proxy Error. Is Tor running?'
                print(message)
                return self.error_icon, 'error'

            old_unixtime = (time.time())

            for pool in self.pools:
                if not pool.done:
                    for url in pool.url_random:
                        pool.done = url in self.valid_urls
                        if pool.done:
                            valid_url = url
                            ## Values are returned randomly. Get the index of the url.
                            index = self.valid_urls.index(valid_url)
                            ## Pool matching web time.
                            web_unixtime = int(self.unixtimes[index])
                            web_time = (datetime.strftime(datetime.fromtimestamp(web_unixtime),
                                                        '%a %b %d %H:%M:%S UTC %Y'))
                            pool_diff = int(web_unixtime) - int(old_unixtime)
                            self.pools_diff.append(pool_diff)
                            pool_number = self.pools.index(pool) + 1
                            message = ('Pool %s last url: %s, web unixtime: %s, web time: %s, diff: %s seconds'
                                       % (pool_number, valid_url, web_unixtime, web_time, pool_diff))
                            print(message)
                            logger.info(message)

        message = 'Reachable urls:\n'
        for url in self.valid_urls:
            url_comment = self.get_comment(url)
            message = message + '%s: "%s"\n' % (url, url_comment)
        print(message.strip())
        logger.info(message.strip())

        message = 'Unreachable urls:\n'
        for url in self.invalid_urls:
            url_comment = self.get_comment(url)
            message = message + '%s: "%s"\n' % (url, url_comment)
        print(message.strip())
        logger.info(message.strip())

        end_unixtime = time.time()
        end_time = (datetime.strftime(datetime.fromtimestamp(start_unixtime),
                                        '%a %b %d %H:%M:%S UTC %Y'))
        message = ('Fetching remote times, end %s (unixtime %s)'
                   % (end_time, end_unixtime))
        print(message)
        logger.info(message)

        last_shell_date = check_output('date').strip()
        self.message = 'Last run (on ' + last_shell_date + ') was successful'
        retrying_loop = False
        return self.success_icon, 'success'


def signal_sigterm_handler(signum, frame):
    # Inform sdwdate-gui
    icon = sdwdate.error_icon
    message = 'sdwdate stopped, signal SIGTERM received'
    sdwdate.write_status(icon, message)

    if sdwdate.sclockadj_pid != 0:
        sdwdate.kill_sclockadj()

    logger.info('Signal SIGTERM received. Exiting.')
    sys.exit(143)

if __name__ == "__main__":
    ## When restarted from sdwdate-gui, allow sufficient time between
    ## status changes. See related comment in sdwdate-gui.
    time.sleep(0.2)

    signal.signal(signal.SIGTERM, signal_sigterm_handler)

    logger = logging.getLogger('sdwdate_log')
    logger.setLevel(logging.INFO)
    formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
    handler = logging.FileHandler('/var/log/sdwdate.log')
    handler.setFormatter(formatter)
    logger.addHandler(handler)

    retrying_loop = False

    while True:
        sdwdate = Sdwdate()
        icon, status = sdwdate.sdwdate_loop()

        if status == 'success':
            sdwdate.build_median()
            sdwdate.add_subtract_nanoseconds()
            if sdwdate.set_new_time():
                if sdwdate.success:
                    sdwdate.run_sclockadj()
                else:
                    sdwdate.set_time_using_date()
            if not sdwdate.first_success:
                f = open(sdwdate.first_success_path, 'w')
                f.close()

            f = open(sdwdate.success_path, 'w')
            f.close()
            sleep_time = 10
            log_level = 'info'

        elif status == 'retry':
            sleep_time = 0.1
            log_level = 'warning'

        elif status == 'error':
            sleep_time = 10
            log_level = 'warning'

        message = '%s.<br> Sleeping for %s minutes.' % (sdwdate.message, sleep_time)
        stripped_message = re.sub('<[^<]+?>', '', message)

        sdwdate.write_status(icon, message)

        if log_level == 'info':
            logger.info(stripped_message)
        elif log_level == 'warning':
            logger.warning(stripped_message)

        print(stripped_message)

        time.sleep(sleep_time * 60)
        if sdwdate.sclockadj_pid != 0:
            sdwdate.kill_sclockadj()
