#!/usr/bin/env python

import sys
import logging
import signal
import gevent
import os
import time
import random
from random import randint
from subprocess import Popen, call, PIPE, check_output
import pickle

from sdwdate.url_to_unixtime import url_to_unixtime
from sdwdate.config import read_pools
from sdwdate.timesanitycheck import timesanitycheck


class Sdwdate():
    def __init__(self):
        self.pool_one, self.pool_two, self.pool_three = read_pools()

        self.iteration = 0

        self.range_pool_one = len(self.pool_one)
        self.range_pool_two = len(self.pool_two)
        self.range_pool_three = len(self.pool_three)

        self.number_of_pools = 3

        self.pool_one_done = False
        self.pool_two_done = False
        self.pool_three_done = False

        self.already_picked_index_pool_one = []
        self.already_picked_index_pool_two = []
        self.already_picked_index_pool_three = []

        self.urls = []
        self.url_random = []

        self.url_random_pool_one = []
        self.url_random_pool_two = []
        self.url_random_pool_three = []

        self.valid_urls = []
        self.unixtimes = []
        self.pools_diff = []

        self.invalid_urls = []
        self.url_errors = []

        self.median = 0
        self.range_nanoseconds = 999999999
        self.new_diff = 0
        self.newdiff_nanoseconds = 0

        self.sclockadj_pid = 0

        self.last_shell_date = ''

        self.first_success_path = '/var/run/sdwdate/first_success'
        self.success_path = '/var/run/sdwdate/success'
        self.status_path = '/var/run/sdwdate/status'

        self.success_icon = '/usr/share/icons/sdwdate-gui/Ambox_currentevent.svg.png'
        self.busy_icon = '/usr/share/icons/sdwdate-gui/620px-Ambox_outdated.svg.png'
        self.error_icon = '/usr/share/icons/sdwdate-gui/212px-Timeblock.svg.png'

        self.first_success = os.path.exists(self.first_success_path)
        self.success = os.path.exists(self.success_path)

        self.status = {'icon' : '', 'message' : ''}

        self.message = ''

        message = 'Fetching remote times, start %s' % (time.time())
        print(message)
        logger.info(message)

    def general_proxy_error(self, pools):
        '''
        This error occurs (at least) when Tor is not running.
        '''
        if (pools[0] == 'Connection closed unexpectedly' and
            pools[1] == 'Connection closed unexpectedly' and
            pools[2] == 'Connection closed unexpectedly'):
                return True
        return False

    def check_remote(self, remote, value):
        '''
        Check returned value. True if numeric.
        '''
        try:
            n = int(value)
            message = 'Remote status "%s", True' % (remote)
            print(message)
            logger.info(message)
            return True
        except ValueError:
            message = 'Remote status "%s", False: %s' % (remote, value)
            print(message)
            logger.info(message)
            return False

    def time_sanity_check(self):
        status, time_one, time_two = timesanitycheck()

        if status == 'sane':
            self.message = 'The clock is %s. Current time "%s"' % (status, time_one)
        elif status == 'slow':
            self.message = ('The clock is %s. Current time "%s" is less than the build timestamp "%s"'
                % (status, time_one, time_two))
        elif status == 'fast':
            self.message = ('The clock is %s. Current time "%s" is greater than the expiration timestamp "%s"'
                % (status, time_one, time_two))
        return status

    def sdwdate_loop(self):
        '''
        Check remotes.
        Pick a random url in eaxh pool, check the returned value.
        Append valid urls if time is returned, otherwise restart a cycle
        with a new random url, until every pool has a time value.
        '''
        time_sanity_check = self.time_sanity_check()
        if time_sanity_check == 'sane':
            print self.message
            logger.info(self.message)
        else:
            print self.message
            return self.error_icon, 'error'

        global retrying_loop

        if self.success:
            if not retrying_loop:
                ## Update tool tip.
                ## Update icon after SIGTERM.
                self.write_status(self.success_icon, 'Fetching remote times...')
        else:
            if not self.first_success:
                self.write_status(self.busy_icon, 'No internet. Fetching remote times...')
            else:
                self.write_status(self.success_icon, 'Fetching remote times...')

        while len(self.valid_urls) < self.number_of_pools:
            self.iteration = self.iteration + 1
            message = 'Running sdwdate loop, iteration %s' % (self.iteration)
            print(message)
            logger.info(message)

            ## Clear the lists.
            self.urls[:] = []
            self.url_random[:] = []

            if not self.pool_one_done:
                url_index = []
                while url_index not in self.already_picked_index_pool_one:
                    url_index = random.sample(range(self.range_pool_one), 1)

                    if len(self.already_picked_index_pool_one) >= len(self.pool_one):
                        self.message = ' Time is not set: no valid time returned from pool one'
                        logger.warning(self.message)
                        return self.error_icon, 'error'

                    self.already_picked_index_pool_one.append(url_index)
                    self.url_random_pool_one.append(self.pool_one[url_index[0]])
                    self.url_random.append(self.pool_one[url_index[0]])

            if not self.pool_two_done:
                url_index = []
                while url_index not in self.already_picked_index_pool_two:
                    url_index = random.sample(range(self.range_pool_two), 1)

                    if len(self.already_picked_index_pool_two) >= len(self.pool_two):
                        self.message = ' Time is not set: no valid time returned from pool two'
                        logger.warning(self.message)
                        return self.error_icon, 'error'

                    self.already_picked_index_pool_two.append(url_index)
                    self.url_random_pool_two.append(self.pool_two[url_index[0]])
                    self.url_random.append(self.pool_two[url_index[0]])

            if not self.pool_three_done:
                url_index = []
                while url_index not in self.already_picked_index_pool_three:
                    url_index = random.sample(range(self.range_pool_three), 1)

                    if len(self.already_picked_index_pool_three) >= len(self.pool_three):
                        self.message = 'Time is not set: no valid time returned from pool three'
                        logger.warning(self.message)
                        return self.error_icon, 'error'

                    self.already_picked_index_pool_three.append(url_index)
                    self.url_random_pool_three.append(self.pool_three[url_index[0]])
                    self.url_random.append(self.pool_three[url_index[0]])

            ## Fetch remotes.
            if len(self.url_random) > 0:
                message = 'Requested urls %s' % (self.url_random)
                print(message)
                logger.info(message)

                self.urls, self.returned_values = url_to_unixtime(self.url_random)

                if len(self.urls) == 0:
                    if retrying_loop:
                        retrying_loop = False
                        self.message = 'No values returned from url_to_unixtime. Internet connection might be down.'
                        return self.error_icon, 'error'
                    else:
                        retrying_loop = True
                        self.message = 'No values returned from url_to_unixtime. Retrying...'
                        return self.busy_icon, 'retry'

                message = 'Returned urls "%s"' % (self.urls)
                print(message)
                logger.info(message)

            else:
                self.message = ('Something is wrong. sdwdate loop could not build a list or urls.\n' +
                                'Please report this bug')
                print(message)
                return self.error_icon, 'error'

            if not self.general_proxy_error(self.returned_values):
                for i in range(len(self.urls)):
                    if self.check_remote(self.urls[i], self.returned_values[i]):
                        self.valid_urls.append(self.urls[i])
                        self.unixtimes.append(self.returned_values[i])
                    else:
                        self.invalid_urls.append(self.urls[i])
                        self.url_errors.append(self.returned_values[i])
            else:
                self.message = 'General Proxy Error. Is Tor running?'
                print(message)
                return self.error_icon, 'error'

            old_unixtime = (time.time())

            if not self.pool_one_done:
                for i in range(len(self.url_random_pool_one)):
                    self.pool_one_done = self.url_random_pool_one[i] in self.valid_urls
                    if self.pool_one_done:
                        valid_url = self.url_random_pool_one[i]
                        ## Values are teturned randomly. Get the index of the url.
                        index = self.valid_urls.index(valid_url)
                        ## Pool matching web time.
                        web_time = self.unixtimes[index]
                        self.pools_diff.append(int(web_time) - int(old_unixtime))
                        message = 'Pool one: last_url %s, web_time %s' % (valid_url, web_time)
                        print(message)
                        logger.info(message)

            if not self.pool_two_done:
                for i in range(len(self.url_random_pool_two)):
                    self.pool_two_done = self.url_random_pool_two[i] in self.valid_urls
                    if self.pool_two_done:
                        valid_url = self.url_random_pool_two[i]
                        index = self.valid_urls.index(valid_url)
                        web_time = self.unixtimes[index]
                        self.pools_diff.append(int(web_time) - int(old_unixtime))
                        message = 'Pool two: last_url %s, web_time %s' % (valid_url, web_time)
                        print(message)
                        logger.info(message)

            if not self.pool_three_done:
                for i in range(len(self.url_random_pool_three)):
                    self.pool_three_done = self.url_random_pool_three[i] in self.valid_urls
                    if self.pool_three_done:
                        valid_url = self.url_random_pool_three[i]
                        index = self.valid_urls.index(valid_url)
                        web_time = self.unixtimes[index]
                        self.pools_diff.append(int(web_time) - int(old_unixtime))
                        message = 'Pool three: last_url %s, web_time %s' % (valid_url, web_time)
                        print(message)
                        logger.info(message)

        message = 'Valid urls %s' % (self.valid_urls)
        print(message)
        logger.info(message)

        message = 'Bad urls %s' % (self.invalid_urls)
        print(message)
        logger.info(message)

        message = 'Fetching remote times, end %s' % (time.time())
        print(message)
        logger.info(message)

        last_shell_date = check_output('date').strip()
        self.message = 'Last run (on ' + last_shell_date + ') was successful.'
        retrying_loop = False
        return self.success_icon, 'success'

    def build_median(self):
        '''
        Get the median (not average) from the list of values.
        '''
        diffs = sorted(self.pools_diff)
        message = 'Pool differences, sorted: %s' % diffs
        print(message)
        logger.info(message)
        self.median = diffs[(len(diffs) / 2)]

    def set_new_time(self):
        '''
        Do not set time if diff = 0.
        '''
        if self.median == 0:
            message = 'Time difference = 0. Not setting time'
            print(message)
            logger.info(message)
            return False
        else:
            return True

    def add_subtract_nanoseconds(self):
        '''
        Could we replace this in sdwdate_loop pool_diff calcuations?
        -> int(web_time) - old_unixtime
        '''
        signs = ['+', '-']
        sign = randint(0, 1)
        nanoseconds = randint(0, self.range_nanoseconds)
        seconds = float(nanoseconds) / 1000000000

        if sign == 0:
            self.new_diff = self.median + seconds
        else:
            self.new_diff = self.median - seconds

        self.newdiff_nanoseconds = int(self.new_diff * 1000000000)

        #print 'nanoseconds %s' % nanoseconds
        message = 'Median time difference: %s' % self.median
        print(message)
        logger.info(message)
        message = 'Seconds to add: %s %s' % (signs[sign], seconds)
        print(message)
        logger.info(message)
        message = 'New time difference: %s' % self.new_diff
        print(message)
        logger.info(message)

    def run_sclockadj(self):
        '''
        Set time with sneaky_clock_adjuster.
        Should we use sclockadj_debug_helper?
        '''
        if self.newdiff_nanoseconds > 0:
            add_subtract = "--add"
        else:
            add_subtract = "--subtract"
        cmd = [
            "sudo",
            "INLINEDIR=/var/cache/sdwdate/sclockadj",
            "/usr/lib/sdwdate/sclockadj",
            "--no-debug",
            "--no-verbose",
            "--no-systohc",
            "--no-first-wait",
            "--move-min", "5000000",
            "--move-max", "5000000",
            "--wait-min", "1000000000",
            "--wait-max", "1000000000",
            add_subtract, str(abs(self.newdiff_nanoseconds))]

        ## Run sclockadj in a subshell.
        sclockadj = Popen(cmd)
        self.sclockadj_pid = sclockadj.pid

        message = 'Running sclockaj, PID=%s' % (self.sclockadj_pid)
        print(message)
        logger.info(message)

        ## Running sclockadj_debug_helper, in case...
        ## May be read the last line to ensure sclockadj is running.
        #cmd = ["sudo", "/usr/lib/sdwdate/sclockadj_debug_helper"]
        ### Pipe stdout in subprocess.
        #helper = Popen(cmd, stdout=PIPE)
        ### Read the output.
        #line = helper.stdout.read()
        #print line

    def kill_sclockadj(self):
        '''
        '''
        cmd = 'sudo /usr/lib/sdwdate/sclockadj_kill_helper ' + str(self.sclockadj_pid)
        call(cmd, shell=True)

    def set_time_using_date(self):
        message = 'Setting time using date.'
        print(message)
        logger.info(message)

        old_unixtime = float('%.9f' % (time.time()))
        message = 'Old unixttime: %s' % (str(old_unixtime))
        print(message)
        logger.info(message)

        new_unixtime = float('%.9f' % (old_unixtime + self.new_diff))
        message = 'New unixtime %s' % (str(new_unixtime))
        print(message)
        logger.info(message)

        ## Set new time.
        cmd = 'sudo /bin/date --set @' + str(new_unixtime)
        call(cmd, shell=True)

    def write_status(self, *args):
        self.status['icon'] = args[0]
        self.status['message'] = args[1]
        with open(self.status_path, 'wb') as f:
            pickle.dump(self.status, f)


def signal_sigterm_handler():
    # Inform sdwdate-gui
    icon = sdwdate.error_icon
    message = 'sdwdate stopped, signal SIGTERM received'
    sdwdate.write_status(icon, message)

    if sdwdate.sclockadj_pid != 0:
        sdwdate.kill_sclockadj()

    logger.info('Signal SIGTERM received. Exiting.')
    sys.exit(143)

if __name__ == "__main__":
    gevent.signal(signal.SIGTERM, signal_sigterm_handler)

    logger = logging.getLogger('sdwdate_log')
    logger.setLevel(logging.INFO)
    formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
    handler = logging.FileHandler('/var/log/sdwdate.log')
    handler.setFormatter(formatter)
    logger.addHandler(handler)

    retrying_loop = False

    while True:
        sdwdate = Sdwdate()
        icon, status = sdwdate.sdwdate_loop()

        if status == 'success':
            sdwdate.build_median()

            if sdwdate.success:
                if sdwdate.set_new_time():
                    sdwdate.add_subtract_nanoseconds()
                    sdwdate.run_sclockadj()
            else:
                if not sdwdate.first_success:
                    f = open(sdwdate.first_success_path, 'w')
                    f.close()
                f = open(sdwdate.success_path, 'w')
                f.close()

                if sdwdate.set_new_time():
                    sdwdate.add_subtract_nanoseconds()
                    sdwdate.set_time_using_date()

            message = sdwdate.message + '\nSleeping.'
            sdwdate.write_status(icon, message)
            sleep_time = 10

        elif status == 'retry':
            logger.warning(sdwdate.message)
            print(sdwdate.message)
            sdwdate.write_status(icon, sdwdate.message)
            #print icon
            sleep_time = 0.1

        elif status == 'error':
            logger.warning(sdwdate.message)
            print(sdwdate.message)
            sdwdate.write_status(icon, sdwdate.message)
            sleep_time = 10

        message = 'Sleeping for %s minutes' % (sleep_time)
        print(message)
        logger.info(message)
        time.sleep(sleep_time * 60)
        if sdwdate.sclockadj_pid != 0:
            sdwdate.kill_sclockadj()
